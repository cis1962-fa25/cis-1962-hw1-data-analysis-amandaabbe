[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/PA8fMuFu)

# Homework 1 AI Synthesis Activity

Only complete one of the assignments below! You can delete the other assignment in this document once you've made your choice.

## Activity: You used AI

### Part 1

> Cite the usage by including screenshots, a text transcript, or a link to the conversation with your AI of choice. Make sure to include any context, instructions, and all the conversations you had with the AI.

### Part 2

> Write about why you used AI. Was there a gap in knowledge you wanted to fill? Were the answers through traditional search engines not adequate? Did you want to let AI help you format something in a quick manner?

### Part 3

> Evaluate the AI's response. If you asked multiple questions, you can pick one of the responses the AI generated. Does the AI answer your question properly? Does it hallucinate any details? Could there be room to improve this response through manual editing? Did you accept this response fully or adapt parts of it into your work?

### Part 4

> If you used unfamiliar syntax or concepts generated by AI within your assignment, be sure to research them and explain what those concepts are to demonstrate your understanding.

---

## Activity B: You did NOT use AI

### Part 1

> Explain some improvement you want to make within your code. Perhaps you have a code block that could be more concise, or a part of your code could be improved with a library or be performed with a more efficient algorithm.

My code works and passes tests, but I'd improve the sentiment analysis section by reducing mutation and duplication. Instead of mutating review.sentiment, I'd produce a derived array that adds a sentiment field immutably. I'd also DRY up the nearly identical "count positive/neutral/negative by key" logic in sentimentAnalysisApp and sentimentAnalysisLang into one reusable helper. As small polish, I'd extract rating thresholds to named constants and use a case-insensitive boolean parser for verified_purchase. The goal is to keep functions pure and return new structures without side effects.

### Part 2

> Ask AI how to improve your code, by picking a part of your program you are interested in improving and asking something along the lines of "how can I improve this code?" This does not have to be verbatim; you could ask more specific questions for improvement, like "what JavaScript libraries could improve the efficiency of my code?" Screenshot or link the response.

I asked AI: "Here's my working JS for sentiment analysis on a cleaned reviews array. How can I refactor it to avoid mutation and remove duplication between 'by app' and 'by language'? Please keep it vanilla JS (no extra libraries), O(n), and ESLint-friendly (prefer-const, consistent destructuring, no var). Return production-ready code."

Its output:

// thresholds as named constants
const POSITIVE_MIN = 4.0;
const NEGATIVE_MAX = 2.0;

const labelSentiment = ({ rating }) =>
  rating > POSITIVE_MIN ? 'positive' : (rating < NEGATIVE_MAX ? 'negative' : 'neutral');

const withSentiment = (reviews) =>
  reviews.map((r) => {
    const { rating } = r;
    const sentiment = labelSentiment({ rating });
    return { ...r, sentiment };
  });

const tallySentiments = (items, keyFn, keyProp) => {
  const map = new Map(); // key -> { positive, neutral, negative }
  for (const item of items) {
    const key = keyFn(item);
    if (!map.has(key)) map.set(key, { positive: 0, neutral: 0, negative: 0 });
    const buckets = map.get(key);
    buckets[item.sentiment] += 1;
  }
  return Array.from(map.entries()).map(([k, v]) => ({ [keyProp]: k, ...v }));
};

// Replacements for existing functions (pure + DRY)
const sentimentAnalysisApp = (cleaned) =>
  tallySentiments(withSentiment(cleaned), (r) => r.app_name, 'app_name');

const sentimentAnalysisLang = (cleaned) =>
  tallySentiments(withSentiment(cleaned), (r) => r.review_language, 'lang_name');

### Part 3

> Evaluate the response the AI generates. You may need to do some research to do this evaluation, to see if the syntax generates correctly or if any libraries the AI suggests are appropriate for the current task. Report on whether the AI's solution fits within your project, or if it would need modifications to work properly.

The refactor the AI proposed is logically correct and would preserve behavior: it keeps the same sentiment thresholds, returns the same output shapes for both app and language, and should pass the existing tests. It's also clean and idiomatic—arrow functions, destructuring, const everywhere, and named constants make the code self-documenting and lint-friendly. That said, it adds another traversal via withSentiment, which pushes the work from a single pass to roughly two passes; on 2,514 rows the cost is negligible, but it's still extra complexity and an extra abstraction layer (tallySentiments) for what is, in this assignment, a simple counting task. My current implementation is already clear, passes all tests, and conforms to the style guide, so the marginal win from refactoring right now is low, and changing structure right before grading risks unintended drift from the autograder's expectations. The suggestion is solid and I’d consider it in a longer-lived codebase, but I'm not adopting it for this submission.

**_ You do NOT need to use the AI suggestion within your final submission, if your code already works properly. If the scope of your inquiry in this activity leads you to replace parts of your code, switch to the other version of this activity instead. _**
